<?php
namespace MSM;

trait ModelTrait {
    /**
     * 
     * @var Table
     */
    protected static $_defaultTable;

    /**
	 * Default adapter object.
	 *
	 * @var Adapter
	 */
	protected static $_db;

	/**
	 * The schema name (default null means current schema)
	 *
	 * @var array
	 */
	protected static $_schema = null;

	/**
	 * The table name.
	 *
	 * @var string
	 */
	protected static $_name = null;

	/**
	 * The primary key column or columns.
	 * MUST be declared as an array.
	 *
	 * @var array
	 */
	protected static $_primary = null;

	/**
	 * If your primary key is a compound key, and one of the columns uses
	 * an auto-increment or sequence-generated value, set _identity
	 * to the ordinal index in the $_primary array for that column.
	 * Note this index is the position of the column in the primary key,
	 * not the position of the column in the table.  The primary key
	 * array is 0-based.
	 *
	 * @var integer
	 */
	protected static $_identity = 0;

	/**
	 * Define the logic for new values in the primary key.
	 * May be a string, boolean true, or boolean false.
	 *
	 * @var mixed
	 */
	protected static $_sequence = true;

    /**
     * @var Table
     */
    protected $_table;
    
    /**
     * 
     * @return Table
     */
    public static function getDefaultTable(){
		if (!isset(self::$_defaultTable)){
			self::$_defaultTable = new Table([
				Table::ADAPTER=> static::$_db,
				Table::SCHEMA => static::$_schema,
				Table::NAME   => static::$_name,
				Table::PRIMARY=> static::$_primary,
				Table::SEQUENCE=>static::$_sequence,
			    Table::ROW_CLASS=>static::class,
				]);
		}
		return self::$_defaultTable;
	}
	
	public static function getTable(){
	    return static::getDefaultTable();
	}
	
	/**
	 * 
	 * @param Table $table
	 */
	public function setTable($table){
	    $this->_table = $table;
	    return $this;
	}
	
	/**
	 * Fetches a new blank row (not from the database).
	 *
	 * @param  array $data OPTIONAL data to populate in the new row.
	 * @param  string $defaultSource OPTIONAL flag to force default values into new row
	 * @return DataObject
	 */
	public static function createRow(array $data = [])
	{
	    return static::createRow($data)->setTable(static::getDefaultTable());
	}

	/**
	 * Returns an instance of a Select object.
	 *
	 * @param bool $withFromPart Whether or not to include the from part of the select based on the table
	 * @return Select
	 */
	public static function select($columns = null)
	{
	    return static::getDefaultTable()->selectCol($columns);
	}
	
	/**
	 * Fetches rows by primary key.  The argument specifies one or more primary
	 * key value(s).  To find multiple rows by primary key, the argument must
	 * be an array.
	 *
	 * This method accepts a variable number of arguments.  If the table has a
	 * multi-column primary key, the number of arguments must be the same as
	 * the number of columns in the primary key.  To find multiple rows in a
	 * table with a multi-column primary key, each argument must be an array
	 * with the same number of elements.
	 *
	 * The find() method always returns a Rowset object, even if only one row
	 * was found.
	 *
	 * @param  mixed $key The value(s) of the primary keys.
	 * @return Statement Row(s) matching the criteria.
	 * @throws DataObjectException
	 */
	public static function find()
	{
	    return call_user_func_array([static::getDefaultTable(), 'find'], func_get_args());
	}
	
	/**
	 *
	 * @return \SplFixedArray
	 */
	public static function fetchAllByPrimary($keys){
	    return static::getDefaultTable()->fetchAllByPrimary($keys);
	}
	/*  向下兼容部分代码结束 */
	
	/**
	 * @return mixed The primary key value(s), as an associative array if the
	 *	 key is compound, or a scalar if the key is single-column.
	 */
	protected function _doInsert()
	{
		/**
		 * Execute the INSERT (this may throw an exception)
		 */
		$data = array_intersect_key($this->getArrayCopy(), $this->_cleanData);
		$primaryKey = $this->_table->insert($data);

		/**
		 * Save the new primary key value in _data.  The primary key may have
		 * been generated by a sequence or auto-increment mechanism, and this
		 * merge should be done before the _postInsert() method is run, so the
		 * new values are available for logging, etc.
		 */
		$this->setFromArray($primaryKey);

		return $primaryKey;
	}

	/**
	 * @return mixed The primary key value(s), as an associative array if the
	 *	 key is compound, or a scalar if the key is single-column.
	 */
	protected function _doUpdate()
	{
		/**
		 * Get expressions for a WHERE clause
		 * based on the primary key value(s).
		 */
		$where = $this->_getWhereQuery(false);

		/**
		 * Compare the data to the modified fields array to discover
		 * which columns have been changed.
		 */
		$diffData = array_intersect_key($this->getArrayCopy(), $this->_cleanData);

		/**
		 * Execute the UPDATE (this may throw an exception)
		 * Do this only if data values were changed.
		 * Use the $diffData variable, so the UPDATE statement
		 * includes SET terms only for data values that changed.
		 */
		if (count($diffData) > 0) {
			$this->_table->update($diffData, $where);
		}

		/**
		 * Return the primary key value(s) as an array
		 */
		$primaryKey = $this->_getPrimaryKey(true);

		return $primaryKey;
	}

	/**
	 * Deletes existing rows.
	 *
	 * @return int The number of rows deleted.
	 */
	protected function _doDelete()
	{
		$where = $this->_getWhereQuery();
		/**
		 * Execute the DELETE (this may throw an exception)
		 */
		return $this->_table->delete($where);
	}

	/**
	 * Retrieves an associative array of primary keys.
	 *
	 * @param bool $useDirty
	 * @return array
	 */
	protected function _getPrimaryKey($useDirty = true)
	{
	    $primary = array_flip($this->_table->getPrimary());
	    if ($useDirty) {
	        $array = array_intersect_key($this->getArrayCopy(), $primary);
	    } else {
	        $array = array_intersect_key($this->_cleanData + $this->getArrayCopy(), $primary);
	    }
	    if (count($primary) != count($array)) {
	        throw new DataObjectException("The specified Table '".get_class($this->_table)."' does not have the same primary key as the Row");
	    }
	    return $array;
	}
	
	/**
	 * Constructs where statement for retrieving row(s).
	 *
	 * @param bool $useDirty
	 * @return array
	 */
	protected function _getWhereQuery($useDirty = true)
	{
	    $where = [];
	
	    $primaryKey = $this->_getPrimaryKey($useDirty);
	    $db = $this->_table->getAdapter();
	    $tableName = $db->quoteIdentifier($this->_table->getName(), true);
	
	    // retrieve recently updated row using primary keys
	    foreach ($primaryKey as $column => $value) {
	        $columnName = $db->quoteIdentifier($column, true);
	        $where[] = $db->quoteInto("{$tableName}.{$columnName} = ?", $value);
	    }
	    return $where;
	}
	
	public function refresh(){
	    $where = $this->_getWhereQuery();
	    $row = $this->_table->select()
	        ->whereClauses($where)
	        ->fetchRow();
	
	    if (null === $row) {
	        throw new DataObjectException('Cannot refresh row as parent is missing');
	    }
	
	    $this->exchangeArray($row->getArrayCopy());
	    $this->_cleanData = [];
	}
}
